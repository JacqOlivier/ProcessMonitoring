import numpy as np
from sklearn.model_selection import train_test_split

from processmonitoring.permutations import permutations

"""
Generic dataset class, that also allows for permutations of the dataset to be created.
Every dataset must inherit from this class.
"""
class DatasetWithPermutations(object):

    def __init__(self, 
                 data_config: dict,
                 save_to_folder: str = None
                 ) -> None:
        """Sets up parameters for time series to be generated by child classes.
           Time series generation also handle here. Make sure additional child class
           parameters are set before super()_is called.

        Args:
            data_config (dict): sub-dict from config file containing parameters initialised below
            save_to_folder (str, optional): Str directory to save plots. Defaults to None.
        """
        
        # Data set required parameters
        self.length = data_config['simulation_length']                          # length of time series to be generated
        self.transition_fraction = data_config['transition_position']           # fraction of length where fault occurs
        self.fault_pos = int(data_config['transition_position']*self.length)    # integer position of fault
        self.permutation = data_config['permutation']                           # string name of required permutation
        self.window_length = data_config['window_length']                       # segmentation window length
        self.stride = data_config['stride']                                     # gap between windows
        self.seed = data_config['seed']                                         # PRNG seed
        self.save_to_folder = save_to_folder                                    
        self.PRNG = np.random.default_rng(seed=self.seed)

        # to be initialised by class methods
        self.time_series = None                 # needs to be a shape (n,) or (n,1) np.ndarray
        self.labels = None

        # init should contain the following sequence of methods to be utilised elsewhere
        self._generate_data()
        self._segment_and_split()
        self._generate_permuted_dataset()

        if self.save_to_folder:
            self._plot_to_folder()

    def _generate_data(self) -> None:
        # specific data generation scheme of subclass
        # raise error if not implemented in subclasses
        # must generate:
        #   self.time_series
        #   self.labels
        raise NotImplementedError()
    
    def _segment_and_split(self) -> None:
        """
        Segments the generated time series into overlapping windows.
        Training set is the NOC data, excluding an additional validation set containing the last 30% of the NOC data.
        Test data only contains the fault data (just conventions). 
        Generates:
            self.X: full dataset segmented into NxM matrix, with N windows each consisting of M samples in the window
            self.y: array of 0's and 2's, for a normal or fault sample in X, respectively.
            self.X_tr: training partition of self.X
            self.X_val: validation partition of self.X
            self.X_test: test partition of self.X
            self.y_tr: labels of training partition, full of zeros
            self.y_val: labels of validation partition, full of ones
            self.y_test: labels of test (fault) partition, full of twos
        """

        # segment time series into overlapping sequences 
        self.num_windows = int(((len(self.time_series) - self.window_length)) / self.stride)

        self.X = np.zeros((self.num_windows, self.window_length))
        self.y = np.zeros(self.num_windows)
        for i in range(self.num_windows):
            self.X[i,:] = self.time_series[i*self.stride : i*self.stride+self.window_length]
            y_window = self.labels[i*self.stride : i*self.stride+self.window_length]
            # here the ones are from child class is converted to 2's, indicating the fault occurred in the window
            if 1 in y_window:
                self.y[i] = 2

        # get position where X_tr turns into X_val
        val_position = int(0.7*self.X[self.y==0,:].shape[0])
        # get position of first fault window
        fault_position = np.argmax(self.y==2)

        # make X_tr smaller
        self.X_tr = self.X[self.y==0,:][:val_position]
        self.y_tr = np.zeros((self.X_tr.shape[0],))
        # adjust self.y to account for validation split
        self.y[val_position:fault_position] = 1
        
    def _generate_permuted_dataset(self):
        """
        Generates the permuted dataset, and segments the permuted data into windows.
        Generates:
            self.X_tr_permuted: NxM style matrix containing segmented permuted data
            self.y_tr_permuted: Nx1 label vector containing ones, indicating permuted data.
        Can be used to contrast X_tr and y_tr (full of zeros) with X_tr_permuted and y_tr_permuted (full of 1's)
        """
        # get unrolled length of self.X_tr to determine amount of samples required for training
        real_training_data = self.time_series[:self.X_tr.shape[0]*self.stride+self.window_length]

        permutation = permutations.Permutations(real_training_data, self.PRNG, self.save_to_folder)
        permuted_ts = permutation.get_ts(self.permutation)

        # segment the permuted time series
        num_windows = int(((len(permuted_ts) - self.window_length)) / self.stride)
        self.X_tr_permuted = np.zeros((num_windows, self.window_length))
        for i in range(num_windows):
            self.X_tr_permuted[i,:] = permuted_ts[i*self.stride : i*self.stride+self.window_length]
        
        self.y_tr_permuted = np.ones((num_windows,))

    def _plot_to_folder(self):
        """
        Plots raw time series data, with fault position indicated, to folder
        """
        import os
        import matplotlib.pyplot as plt

        plt.figure(figsize=(16,9))
        plt.plot(self.time_series)
        plt.axvline(self.fault_pos, c='r', linestyle='--')
        plt.xlabel('Time')
        plt.ylabel('y')
        plt.grid(True)
        plt.legend(["Time series", "Fault Position"])
        plt.savefig(fname=os.path.join(self.save_to_folder, self.__class__.__name__))